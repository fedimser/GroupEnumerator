package io.github.fedimser.genum;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Collection of methods to build groups of common types
 * (i.e. cyclic, symmetric, dihedral, etc.)
 */
public final class FinGroupFactory {
    /**
     * Builds cyclic group, i.e. group generated by one element of given order.
     *
     * @param order Order of group (also order of primitive element).
     */
    public static FinGroup getCyclicGroup(int order) {
        int g[][] = new int[order][order];
        for (int i = 0; i < order; i++) {
            for (int j = 0; j < order; j++) {
                g[i][j] = (i + j) % order;
            }
        }
        return new FinGroup(g);
    }

    /**
     * Builds symmetric group, i.e. group of permutations on n elements.
     * Order of returned group is n!
     *
     * @param n number of elements in permutations
     */
    public static FinGroup getSymmetricGroup(int n) {
        int order = Permutation.factorial(n);
        int[][] g = new int[order][order];
        List<Permutation> perms = Permutation.getAllPermutations(n);
        assert (perms.size() == order);

        Map<String, Integer> invIndex = new HashMap<String, Integer>();
        for (int i = 0; i < order; i++) {
            invIndex.put(perms.get(i).toString(), i);
        }

        for (int i = 0; i < order; i++) {
            for (int j = 0; j < order; j++) {
                Permutation res = Permutation.apply(perms.get(i), perms.get(j));
                g[i][j] = invIndex.get(res.toString());
            }
        }

        return new FinGroup(g);
    }


    /**
     * Builds dihedral group, i.e. group of symmetries of regular N-gon.
     *
     * @param verticesCount Number of vertices in polygon. Order of group will be twice more.
     */
    public static FinGroup getDihedralGroup(int verticesCount) {
        int N = verticesCount;
        int order = 2 * N;
        int[][] g = new int[order][order];

        // First N values correspond to simple rotations.
        // The other half correspond flip, followed by rotations.
        // Element with number N represents flip.
        for (int i = 0; i < order; i++) {
            for (int j = 0; j < order; j++) {
                if (i < N && j < N) g[i][j] = (i + j) % N;
                else if (i >= N && j < N) g[i][j] = N + (i + j) % N;
                else if (i < N && j >= N) g[i][j] = N + (j - i + 2 * N) % N;
                else if (i >= N && j >= N) g[i][j] = (j - i + 2 * N) % N;
            }
        }

        return new FinGroup(g);
    }

    private static final String[][] QUATERNION_TABLE = {
            {"1", "-1", "i", "-i", "j", "-j", "k", "-k"},
            {"-1", "1", "-i", "i", "-j", "j", "-k", "k"},
            {"i", "-i", "-1", "1", "k", "-k", "-j", "j"},
            {"-i", "i", "1", "-1", "-k", "k", "j", "-j"},
            {"j", "-j", "-k", "k", "-1", "1", "i", "-i"},
            {"-j", "j", "k", "-k", "1", "-1", "-i", "i"},
            {"k", "-k", "j", "-j", "-i", "i", "-1", "1"},
            {"-k", "k", "-j", "j", "i", "-i", "1", "-1"},
    };

    public static FinGroup quaternionGroup() {
        int[][] g = new int[8][8];
        Map<String, Integer> values = new HashMap<String, Integer>();
        for (int i = 0; i < 8; i++) {
            values.put(QUATERNION_TABLE[0][i], i);
        }
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                g[i][j] = values.get(QUATERNION_TABLE[i][j]);
            }
        }

        return new FinGroup(g);
    }

}
